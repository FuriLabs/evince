From: Jeremy Bicha <jbicha@debian.org>
Date: Thu, 3 Mar 2022 10:30:04 +0100
Subject: Revert "comics: Use libarchive for RAR support"

This reverts commit e25912b3a2fa91d8d05d0a683303a8d0a39541b5.

libarchive 3.6.0 isn't in Debian yet.
---
 backend/comics/ev-archive.c | 68 +++++++++++++++++++++++++++++++++++++++++----
 backend/comics/ev-archive.h |  1 +
 backend/comics/meson.build  |  1 +
 meson.build                 |  2 +-
 4 files changed, 65 insertions(+), 7 deletions(-)

diff --git a/backend/comics/ev-archive.c b/backend/comics/ev-archive.c
index 6586482..04516b8 100644
--- a/backend/comics/ev-archive.c
+++ b/backend/comics/ev-archive.c
@@ -22,6 +22,7 @@
 
 #include <archive.h>
 #include <archive_entry.h>
+#include <unarr/unarr.h>
 #include <gio/gio.h>
 
 #define BUFFER_SIZE (64 * 1024)
@@ -33,6 +34,10 @@ struct _EvArchive {
 	/* libarchive */
 	struct archive *libar;
 	struct archive_entry *libar_entry;
+
+	/* unarr */
+	ar_stream *unarr_stream;
+	ar_archive *unarr;
 };
 
 G_DEFINE_TYPE(EvArchive, ev_archive, G_TYPE_OBJECT);
@@ -44,9 +49,13 @@ ev_archive_finalize (GObject *object)
 
 	switch (archive->type) {
 	case EV_ARCHIVE_TYPE_RAR:
+		g_clear_pointer (&archive->unarr, ar_close_archive);
+		g_clear_pointer (&archive->unarr_stream, ar_close);
+		break;
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_clear_pointer (&archive->libar, archive_free);
 		break;
 	default:
@@ -83,10 +92,9 @@ libarchive_set_archive_type (EvArchive *archive,
 		archive_read_support_format_7zip (archive->libar);
 	else if (archive_type == EV_ARCHIVE_TYPE_TAR)
 		archive_read_support_format_tar (archive->libar);
-	else if (archive_type == EV_ARCHIVE_TYPE_RAR) {
-		archive_read_support_format_rar (archive->libar);
+	else if (archive_type == EV_ARCHIVE_TYPE_RAR5)
 		archive_read_support_format_rar5 (archive->libar);
-	} else
+	else
 		g_assert_not_reached ();
 }
 
@@ -107,9 +115,12 @@ ev_archive_set_archive_type (EvArchive *archive,
 
 	switch (archive_type) {
 	case EV_ARCHIVE_TYPE_RAR:
+		archive->type = archive_type;
+		break;
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		libarchive_set_archive_type (archive, archive_type);
 		break;
 	default:
@@ -125,6 +136,7 @@ ev_archive_open_filename (EvArchive   *archive,
 			  GError     **error)
 {
 	int r;
+	ArArchiveError code;
 
 	g_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);
 	g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);
@@ -134,9 +146,28 @@ ev_archive_open_filename (EvArchive   *archive,
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
 	case EV_ARCHIVE_TYPE_RAR:
+		archive->unarr_stream = ar_open_file (path);
+		if (archive->unarr_stream == NULL) {
+			g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+					     "Error opening archive");
+			return FALSE;
+		}
+		archive->unarr = ar_open_rar_archive_with_error (archive->unarr_stream, &code);
+		if (archive->unarr == NULL) {
+			g_clear_pointer (&archive->unarr_stream, ar_close);
+			if (code == AR_ARCHIVE_ERROR_RAR5) {
+				libarchive_set_archive_type (archive, EV_ARCHIVE_TYPE_RAR5);
+				return ev_archive_open_filename (archive, path, error);
+			}
+			g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+					     "Error opening RAR archive");
+			return FALSE;
+		}
+		return TRUE;
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		r = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);
 		if (r != ARCHIVE_OK) {
 			g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
@@ -189,9 +220,11 @@ ev_archive_read_next_header (EvArchive *archive,
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
 	case EV_ARCHIVE_TYPE_RAR:
+		return ar_parse_entry (archive->unarr);
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		return libarchive_read_next_header (archive, error);
 	}
 
@@ -217,9 +250,12 @@ ev_archive_get_entry_pathname (EvArchive *archive)
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
 	case EV_ARCHIVE_TYPE_RAR:
+		g_return_val_if_fail (archive->unarr != NULL, NULL);
+		return ar_entry_get_name (archive->unarr);
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_return_val_if_fail (archive->libar_entry != NULL, NULL);
 		return archive_entry_pathname (archive->libar_entry);
 	}
@@ -234,12 +270,15 @@ ev_archive_get_entry_size (EvArchive *archive)
 	g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);
 
 	switch (archive->type) {
+	case EV_ARCHIVE_TYPE_RAR:
+		g_return_val_if_fail (archive->unarr != NULL, -1);
+		return ar_entry_get_size (archive->unarr);
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
-	case EV_ARCHIVE_TYPE_RAR:
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_return_val_if_fail (archive->libar_entry != NULL, -1);
 		return archive_entry_size (archive->libar_entry);
 	}
@@ -254,12 +293,16 @@ ev_archive_get_entry_is_encrypted (EvArchive *archive)
 	g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);
 
 	switch (archive->type) {
+	case EV_ARCHIVE_TYPE_RAR:
+		g_return_val_if_fail (archive->unarr != NULL, FALSE);
+		/* password-protected RAR is not even detected right now */
+		return FALSE;
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
-	case EV_ARCHIVE_TYPE_RAR:
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_return_val_if_fail (archive->libar_entry != NULL, -1);
 		return archive_entry_is_encrypted (archive->libar_entry);
 	}
@@ -279,12 +322,21 @@ ev_archive_read_data (EvArchive *archive,
 	g_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);
 
 	switch (archive->type) {
+	case EV_ARCHIVE_TYPE_RAR:
+		g_return_val_if_fail (archive->unarr != NULL, -1);
+		if (!ar_entry_uncompress (archive->unarr, buf, count)) {
+			g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+					     "Failed to decompress RAR data");
+			return -1;
+		}
+		r = count;
+		break;
 	case EV_ARCHIVE_TYPE_NONE:
 		g_assert_not_reached ();
-	case EV_ARCHIVE_TYPE_RAR:
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_return_val_if_fail (archive->libar_entry != NULL, -1);
 		r = archive_read_data (archive->libar, buf, count);
 		if (r < 0) {
@@ -305,9 +357,13 @@ ev_archive_reset (EvArchive *archive)
 
 	switch (archive->type) {
 	case EV_ARCHIVE_TYPE_RAR:
+		g_clear_pointer (&archive->unarr, ar_close_archive);
+		g_clear_pointer (&archive->unarr_stream, ar_close);
+		break;
 	case EV_ARCHIVE_TYPE_ZIP:
 	case EV_ARCHIVE_TYPE_7Z:
 	case EV_ARCHIVE_TYPE_TAR:
+	case EV_ARCHIVE_TYPE_RAR5:
 		g_clear_pointer (&archive->libar, archive_free);
 		libarchive_set_archive_type (archive, archive->type);
 		break;
diff --git a/backend/comics/ev-archive.h b/backend/comics/ev-archive.h
index b4e1399..c6af4fa 100644
--- a/backend/comics/ev-archive.h
+++ b/backend/comics/ev-archive.h
@@ -29,6 +29,7 @@ G_DECLARE_FINAL_TYPE (EvArchive, ev_archive, EV, ARCHIVE, GObject)
 typedef enum {
 	EV_ARCHIVE_TYPE_NONE = 0,
 	EV_ARCHIVE_TYPE_RAR,
+	EV_ARCHIVE_TYPE_RAR5,
 	EV_ARCHIVE_TYPE_ZIP,
 	EV_ARCHIVE_TYPE_7Z,
 	EV_ARCHIVE_TYPE_TAR
diff --git a/backend/comics/meson.build b/backend/comics/meson.build
index c245b1b..1e74019 100644
--- a/backend/comics/meson.build
+++ b/backend/comics/meson.build
@@ -7,6 +7,7 @@ incs = backends_incs + [cut_n_paste_inc]
 
 deps = backends_deps + [
   libarchive_dep,
+  libunarr_dep,
 ]
 
 shared_module(
diff --git a/meson.build b/meson.build
index d1f6a7a..e1575f0 100644
--- a/meson.build
+++ b/meson.build
@@ -349,7 +349,7 @@ else
 endif
 
 # *** Comic Book ***
-libarchive_req_version = '>= 3.6.0'
+libarchive_req_version = '>= 3.2.0'
 libarchive_dep = dependency('libarchive', version: libarchive_req_version, required: get_option('comics'))
 enable_comics = libarchive_dep.found()
 if enable_comics
